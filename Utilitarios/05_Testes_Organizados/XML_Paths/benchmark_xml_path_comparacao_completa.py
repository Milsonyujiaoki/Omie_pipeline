#!/usr/bin/env python3
"""
teste_gerar_xml_comparativo.py

Finalidade:
    Teste isolado para comparar as fun√ß√µes gerar_xml_path e gerar_xml_path_otimizado
    e testar a integra√ß√£o no c√≥digo que usa essas fun√ß√µes.

Testes realizados:
    1. Compara√ß√£o de performance entre as duas fun√ß√µes
    2. Verifica√ß√£o de consist√™ncia de resultados
    3. Teste de integra√ß√£o com verificador_xmls.py
    4. An√°lise de casos extremos e edge cases

Autor:
    Equipe de Integra√ß√£o Omie - CorpServices
"""

import os
import sys
import time
import logging
from pathlib import Path
from typing import List, Tuple, Dict, Any
from concurrent.futures import ThreadPoolExecutor, as_completed

# Adiciona o diret√≥rio src ao path para importar utils
sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))

try:
    from src.utils import (
        gerar_xml_path,
        gerar_xml_path_otimizado,
        gerar_nome_arquivo_xml,
        descobrir_todos_xmls,
        normalizar_data
    )
except ImportError:
    # Fallback se executando do diret√≥rio src
    from src.utils import (
        gerar_xml_path,
        gerar_xml_path_otimizado,
        gerar_nome_arquivo_xml,
        descobrir_todos_xmls,
        normalizar_data
    )

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - [%(name)s] %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('teste_gerar_xml_comparativo.log')
    ]
)

logger = logging.getLogger(__name__)

# ============================================================================
# DADOS DE TESTE
# ============================================================================

# Conjunto de dados de teste representativo
DADOS_TESTE = [
    # Formato brasileiro
    ("35250714200166000196550010000123451234567890", "17/07/2025", "123"),
    ("35250714200166000196550010000123461234567891", "17/07/2025", "124"),
    ("35250714200166000196550010000123471234567892", "18/07/2025", "125"),
    
    # Formato ISO
    ("35250714200166000196550010000123481234567893", "2025-07-19", "126"),
    ("35250714200166000196550010000123491234567894", "2025-07-20", "127"),
    
    # Casos extremos
    ("35250714200166000196550010000123501234567895", "21/07/2025", "1"),
    ("35250714200166000196550010000123511234567896", "21/07/2025", "9999"),
    
    # Volume para teste de performance
    *[(f"3525071420016600019655001000012{i:03d}{i:010d}", "22/07/2025", str(i)) 
      for i in range(350, 370)],
    
    # Datas diferentes para teste de estrutura hier√°rquica
    ("35250714200166000196550010000123521234567897", "01/01/2025", "1001"),
    ("35250714200166000196550010000123531234567898", "31/12/2024", "1002"),
]

# ============================================================================
# FUN√á√ïES DE TESTE
# ============================================================================

def testar_consistencia_resultados() -> Dict[str, Any]:
    """
    Testa se ambas as fun√ß√µes retornam resultados consistentes.
    
    Returns:
        Dicion√°rio com resultados do teste de consist√™ncia
    """
    logger.info("üß™ Iniciando teste de consist√™ncia de resultados...")
    
    resultados = {
        "total_testados": 0,
        "identicos": 0,
        "diferentes": 0,
        "erros_original": 0,
        "erros_otimizado": 0,
        "casos_divergentes": []
    }
    
    for chave, dEmi, num_nfe in DADOS_TESTE:
        resultados["total_testados"] += 1
        
        try:
            # Teste fun√ß√£o original
            pasta_orig, arquivo_orig = gerar_xml_path(chave, dEmi, num_nfe)
        except Exception as e:
            logger.warning(f"Erro na fun√ß√£o original para {chave}: {e}")
            resultados["erros_original"] += 1
            continue
            
        try:
            # Teste fun√ß√£o otimizada
            pasta_otim, arquivo_otim = gerar_xml_path_otimizado(chave, dEmi, num_nfe)
        except Exception as e:
            logger.warning(f"Erro na fun√ß√£o otimizada para {chave}: {e}")
            resultados["erros_otimizado"] += 1
            continue
        
        # Compara√ß√£o de resultados
        if str(arquivo_orig) == str(arquivo_otim):
            resultados["identicos"] += 1
        else:
            resultados["diferentes"] += 1
            resultados["casos_divergentes"].append({
                "chave": chave[:20] + "...",
                "dEmi": dEmi,
                "num_nfe": num_nfe,
                "original": str(arquivo_orig),
                "otimizado": str(arquivo_otim)
            })
    
    # Log dos resultados
    logger.info(f"‚úÖ Consist√™ncia: {resultados['identicos']}/{resultados['total_testados']} id√™nticos")
    if resultados["diferentes"] > 0:
        logger.warning(f"‚ö†Ô∏è  {resultados['diferentes']} casos divergentes encontrados")
    
    return resultados

def testar_performance_comparativa(num_iteracoes: int = 100) -> Dict[str, Any]:
    """
    Compara a performance das duas fun√ß√µes com m√∫ltiplas itera√ß√µes.
    
    Args:
        num_iteracoes: N√∫mero de itera√ß√µes para cada fun√ß√£o
        
    Returns:
        Dicion√°rio com m√©tricas de performance
    """
    logger.info(f"‚ö° Iniciando teste de performance ({num_iteracoes} itera√ß√µes)...")
    
    # Prepare dados para teste
    dados_performance = DADOS_TESTE * (num_iteracoes // len(DADOS_TESTE) + 1)
    dados_performance = dados_performance[:num_iteracoes]
    
    # Teste fun√ß√£o original
    inicio_orig = time.perf_counter()
    erros_orig = 0
    for chave, dEmi, num_nfe in dados_performance:
        try:
            gerar_xml_path(chave, dEmi, num_nfe)
        except Exception:
            erros_orig += 1
    tempo_orig = time.perf_counter() - inicio_orig
    
    # Teste fun√ß√£o otimizada
    inicio_otim = time.perf_counter()
    erros_otim = 0
    for chave, dEmi, num_nfe in dados_performance:
        try:
            gerar_xml_path_otimizado(chave, dEmi, num_nfe)
        except Exception:
            erros_otim += 1
    tempo_otim = time.perf_counter() - inicio_otim
    
    # C√°lculo de m√©tricas
    melhoria_percentual = ((tempo_orig - tempo_otim) / tempo_orig) * 100 if tempo_orig > 0 else 0
    
    resultados = {
        "iteracoes": num_iteracoes,
        "tempo_original": tempo_orig,
        "tempo_otimizado": tempo_otim,
        "melhoria_percentual": melhoria_percentual,
        "erros_original": erros_orig,
        "erros_otimizado": erros_otim,
        "ops_por_segundo_original": num_iteracoes / tempo_orig if tempo_orig > 0 else 0,
        "ops_por_segundo_otimizada": num_iteracoes / tempo_otim if tempo_otim > 0 else 0
    }
    
    # Log dos resultados
    logger.info(f"üìä Original: {tempo_orig:.4f}s ({resultados['ops_por_segundo_original']:.1f} ops/s)")
    logger.info(f"üìä Otimizada: {tempo_otim:.4f}s ({resultados['ops_por_segundo_otimizada']:.1f} ops/s)")
    logger.info(f"üìà Melhoria: {melhoria_percentual:+.1f}%")
    
    return resultados

def testar_casos_extremos() -> Dict[str, Any]:
    """
    Testa casos extremos e edge cases.
    
    Returns:
        Dicion√°rio com resultados dos casos extremos
    """
    logger.info(" Testando casos extremos...")
    
    casos_extremos = [
        # Dados inv√°lidos
        ("", "17/07/2025", "123"),
        ("chave_valida", "", "123"),
        ("chave_valida", "17/07/2025", ""),
        (None, "17/07/2025", "123"),
        
        # Datas inv√°lidas
        ("35250714200166000196550010000123451234567890", "32/13/2025", "123"),
        ("35250714200166000196550010000123451234567890", "invalid_date", "123"),
        
        # Chaves muito longas/curtas
        ("a" * 100, "17/07/2025", "123"),
        ("abc", "17/07/2025", "123"),
        
        # N√∫meros NFe extremos
        ("35250714200166000196550010000123451234567890", "17/07/2025", "0"),
        ("35250714200166000196550010000123451234567890", "17/07/2025", "999999999"),
    ]
    
    resultados = {
        "total_casos": len(casos_extremos),
        "tratados_corretamente": 0,
        "erros_inesperados": 0,
        "comportamento_inconsistente": 0
    }
    
    for i, (chave, dEmi, num_nfe) in enumerate(casos_extremos, 1):
        logger.debug(f"Testando caso extremo {i}: {chave}, {dEmi}, {num_nfe}")
        
        # Teste fun√ß√£o original
        erro_orig = None
        try:
            resultado_orig = gerar_xml_path(chave, dEmi, num_nfe)
        except Exception as e:
            erro_orig = type(e).__name__
        
        # Teste fun√ß√£o otimizada
        erro_otim = None
        try:
            resultado_otim = gerar_xml_path_otimizado(chave, dEmi, num_nfe)
        except Exception as e:
            erro_otim = type(e).__name__
        
        # An√°lise de comportamento
        if erro_orig and erro_otim:
            if erro_orig == erro_otim:
                resultados["tratados_corretamente"] += 1
            else:
                resultados["comportamento_inconsistente"] += 1
                logger.warning(f"Comportamento inconsistente: orig={erro_orig}, otim={erro_otim}")
        elif not erro_orig and not erro_otim:
            resultados["tratados_corretamente"] += 1
        else:
            resultados["erros_inesperados"] += 1
            logger.warning(f"Erro inesperado: orig={erro_orig}, otim={erro_otim}")
    
    logger.info(f"üéØ Casos extremos: {resultados['tratados_corretamente']}/{resultados['total_casos']} tratados corretamente")
    
    return resultados

def testar_integracao_verificador() -> Dict[str, Any]:
    """
    Testa a integra√ß√£o com o m√≥dulo verificador_xmls.py.
    
    Returns:
        Dicion√°rio com resultados do teste de integra√ß√£o
    """
    logger.info("üîó Testando integra√ß√£o com verificador_xmls...")
    
    try:
        # Import do verificador
        sys.path.insert(0, str(Path(__file__).parent.parent.parent.parent))
        from verificador_xmls import verificar_arquivo_no_disco_e_validar_campo
        
        resultados = {
            "import_sucesso": True,
            "testes_executados": 0,
            "funciona_com_original": 0,
            "funciona_com_otimizada": 0,
            "erros": []
        }
        
        # Testa alguns casos do DADOS_TESTE
        casos_teste = DADOS_TESTE[:5]  # Primeiros 5 casos
        
        for chave, dEmi, num_nfe in casos_teste:
            resultados["testes_executados"] += 1
            
            try:
                # Simula o comportamento do verificador_xmls
                row = (chave, dEmi, num_nfe)
                resultado = verificar_arquivo_no_disco_e_validar_campo(row)
                
                # Se n√£o deu erro, considera sucesso (arquivo pode ou n√£o existir)
                resultados["funciona_com_original"] += 1
                
                logger.debug(f"Verificador retornou: {resultado} para {chave[:20]}...")
                
            except Exception as e:
                resultados["erros"].append(f"Erro ao testar {chave[:20]}...: {e}")
        
        # Para fun√ß√£o otimizada, precisaria modificar o verificador_xmls
        # Vamos simular isso testando diretamente a fun√ß√£o
        for chave, dEmi, num_nfe in casos_teste:
            try:
                pasta, arquivo = gerar_xml_path_otimizado(chave, dEmi, num_nfe)
                # Se a fun√ß√£o n√£o deu erro, considera sucesso
                resultados["funciona_com_otimizada"] += 1
            except Exception as e:
                resultados["erros"].append(f"Erro na fun√ß√£o otimizada {chave[:20]}...: {e}")
        
        logger.info(f"‚úÖ Integra√ß√£o: {resultados['funciona_com_original']}/{resultados['testes_executados']} casos funcionam")
        
    except ImportError as e:
        resultados = {
            "import_sucesso": False,
            "erro_import": str(e),
            "testes_executados": 0
        }
        logger.error(f"‚ùå Falha ao importar verificador_xmls: {e}")
    
    return resultados

def testar_descobrir_xmls_integracao() -> Dict[str, Any]:
    """
    Testa especificamente a integra√ß√£o com descobrir_todos_xmls.
    
    Returns:
        Dicion√°rio com resultados do teste de descobrir_todos_xmls
    """
    logger.info("üìÇ Testando integra√ß√£o com descobrir_todos_xmls...")
    
    resultados = {
        "pasta_resultado_existe": False,
        "xmls_encontrados": 0,
        "funcao_executou": False,
        "tempo_execucao": 0,
        "erros": []
    }
    
    try:
        # Verifica se pasta resultado existe
        pasta_resultado = Path("resultado")
        if not pasta_resultado.exists():
            # Tenta pasta relativa do src
            pasta_resultado = Path("../resultado")
        
        if pasta_resultado.exists():
            resultados["pasta_resultado_existe"] = True
            
            inicio = time.perf_counter()
            xmls = descobrir_todos_xmls(pasta_resultado)
            resultados["tempo_execucao"] = time.perf_counter() - inicio
            
            resultados["xmls_encontrados"] = len(xmls)
            resultados["funcao_executou"] = True
            
            logger.info(f"üìä Descobertos {len(xmls)} XMLs em {resultados['tempo_execucao']:.3f}s")
            
            # Teste com alguns XMLs encontrados (se houver)
            if xmls:
                logger.info(f"üìù Exemplo de XMLs encontrados:")
                for i, xml in enumerate(xmls[:3]):  # Primeiros 3
                    logger.info(f"   {i+1}. {xml}")
        else:
            logger.warning("‚ö†Ô∏è  Pasta 'resultado' n√£o encontrada")
            
    except Exception as e:
        resultados["erros"].append(str(e))
        logger.error(f"‚ùå Erro ao testar descobrir_todos_xmls: {e}")
    
    return resultados

# ============================================================================
# FUN√á√ÉO PRINCIPAL DE TESTE
# ============================================================================

def executar_suite_completa() -> Dict[str, Any]:
    """
    Executa a suite completa de testes comparativos.
    
    Returns:
        Dicion√°rio com todos os resultados dos testes
    """
    logger.info("üöÄ Iniciando suite completa de testes comparativos...")
    
    suite_resultados = {
        "inicio": time.strftime("%Y-%m-%d %H:%M:%S"),
        "consistencia": {},
        "performance": {},
        "casos_extremos": {},
        "integracao_verificador": {},
        "descobrir_xmls": {},
        "fim": None,
        "duracao_total": 0
    }
    
    inicio_suite = time.perf_counter()
    
    try:
        # 1. Teste de consist√™ncia
        logger.info("\n" + "="*50)
        suite_resultados["consistencia"] = testar_consistencia_resultados()
        
        # 2. Teste de performance
        logger.info("\n" + "="*50)
        suite_resultados["performance"] = testar_performance_comparativa(500)
        
        # 3. Casos extremos
        logger.info("\n" + "="*50)
        suite_resultados["casos_extremos"] = testar_casos_extremos()
        
        # 4. Integra√ß√£o com verificador
        logger.info("\n" + "="*50)
        suite_resultados["integracao_verificador"] = testar_integracao_verificador()
        
        # 5. Teste descobrir_todos_xmls
        logger.info("\n" + "="*50)
        suite_resultados["descobrir_xmls"] = testar_descobrir_xmls_integracao()
        
    except Exception as e:
        logger.error(f"‚ùå Erro durante execu√ß√£o da suite: {e}")
        suite_resultados["erro_suite"] = str(e)
    
    suite_resultados["duracao_total"] = time.perf_counter() - inicio_suite
    suite_resultados["fim"] = time.strftime("%Y-%m-%d %H:%M:%S")
    
    return suite_resultados

def imprimir_relatorio_final(resultados: Dict[str, Any]) -> None:
    """
    Imprime relat√≥rio final dos testes.
    
    Args:
        resultados: Dicion√°rio com todos os resultados dos testes
    """
    print("\n" + "="*80)
    print("üìã RELAT√ìRIO FINAL - COMPARA√á√ÉO gerar_xml_path vs gerar_xml_path_otimizado")
    print("="*80)
    
    print(f" Dura√ß√£o total: {resultados['duracao_total']:.2f}s")
    print(f"üïê In√≠cio: {resultados['inicio']}")
    print(f"üïê Fim: {resultados['fim']}")
    
    # Consist√™ncia
    if resultados.get("consistencia"):
        cons = resultados["consistencia"]
        print(f"\nüß™ CONSIST√äNCIA:")
        print(f"   ‚úÖ Id√™nticos: {cons.get('identicos', 0)}/{cons.get('total_testados', 0)}")
        print(f"   ‚ö†Ô∏è  Diferentes: {cons.get('diferentes', 0)}")
        print(f"   ‚ùå Erros original: {cons.get('erros_original', 0)}")
        print(f"   ‚ùå Erros otimizada: {cons.get('erros_otimizado', 0)}")
    
    # Performance
    if resultados.get("performance"):
        perf = resultados["performance"]
        print(f"\n‚ö° PERFORMANCE:")
        print(f"   üìä Original: {perf.get('tempo_original', 0):.4f}s ({perf.get('ops_por_segundo_original', 0):.1f} ops/s)")
        print(f"   üìä Otimizada: {perf.get('tempo_otimizado', 0):.4f}s ({perf.get('ops_por_segundo_otimizada', 0):.1f} ops/s)")
        print(f"   üìà Melhoria: {perf.get('melhoria_percentual', 0):+.1f}%")
    
    # Casos extremos
    if resultados.get("casos_extremos"):
        extremos = resultados["casos_extremos"]
        print(f"\n CASOS EXTREMOS:")
        print(f"   üéØ Tratados corretamente: {extremos.get('tratados_corretamente', 0)}/{extremos.get('total_casos', 0)}")
        print(f"   ‚ö†Ô∏è  Comportamento inconsistente: {extremos.get('comportamento_inconsistente', 0)}")
    
    # Integra√ß√£o
    if resultados.get("integracao_verificador"):
        integ = resultados["integracao_verificador"]
        print(f"\nüîó INTEGRA√á√ÉO:")
        print(f"   ‚úÖ Import sucesso: {integ.get('import_sucesso', False)}")
        print(f"   üîß Funciona com original: {integ.get('funciona_com_original', 0)}")
        print(f"   üîß Funciona com otimizada: {integ.get('funciona_com_otimizada', 0)}")
    
    # descobrir_todos_xmls
    if resultados.get("descobrir_xmls"):
        disc = resultados["descobrir_xmls"]
        print(f"\nüìÇ DESCOBRIR XMLs:")
        print(f"   üìÅ Pasta resultado existe: {disc.get('pasta_resultado_existe', False)}")
        print(f"   üìÑ XMLs encontrados: {disc.get('xmls_encontrados', 0)}")
        print(f"    Tempo execu√ß√£o: {disc.get('tempo_execucao', 0):.3f}s")
    
    print("\n" + "="*80)
    
    # Recomenda√ß√µes
    print("üí° RECOMENDA√á√ïES:")
    
    if resultados.get("performance", {}).get("melhoria_percentual", 0) > 0:
        print("   ‚úÖ A vers√£o otimizada apresenta melhor performance - recomendada para uso")
    else:
        print("   ‚ö†Ô∏è  A vers√£o original apresenta performance similar ou melhor")
    
    if resultados.get("consistencia", {}).get("diferentes", 0) == 0:
        print("   ‚úÖ Resultados consistentes entre as fun√ß√µes - migra√ß√£o segura")
    else:
        print("   ‚ö†Ô∏è  Existem diverg√™ncias - revisar casos antes da migra√ß√£o")
    
    if resultados.get("integracao_verificador", {}).get("import_sucesso", False):
        print("   ‚úÖ Integra√ß√£o com verificador_xmls funcionando")
    else:
        print("   ‚ö†Ô∏è  Problemas na integra√ß√£o com verificador_xmls")
    
    print("="*80)

# ============================================================================
# EXECU√á√ÉO PRINCIPAL
# ============================================================================

if __name__ == "__main__":
    print("üß™ TESTE COMPARATIVO: gerar_xml_path vs gerar_xml_path_otimizado")
    print("="*80)
    
    # Ajusta diret√≥rio de trabalho se necess√°rio
    if os.path.basename(os.getcwd()) == 'src':
        os.chdir('..')
        logger.info("üìÅ Mudando para diret√≥rio raiz do projeto")
    
    logger.info(f"üìÅ Diret√≥rio atual: {os.getcwd()}")
    
    try:
        # Executa suite completa
        resultados = executar_suite_completa()
        
        # Imprime relat√≥rio
        imprimir_relatorio_final(resultados)
        
        # Salva resultados em arquivo
        import json
        with open("teste_gerar_xml_resultados.json", "w", encoding="utf-8") as f:
            json.dump(resultados, f, indent=2, ensure_ascii=False, default=str)
        
        logger.info("üíæ Resultados salvos em teste_gerar_xml_resultados.json")
        
    except Exception as e:
        logger.error(f"‚ùå Erro durante execu√ß√£o dos testes: {e}")
        sys.exit(1)
